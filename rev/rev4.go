/* 4. select case

Go의 select문은 복수 채널들을 기다리면서 준비된 (데이타를 보내온) 채널을 실행하는 기능을 제공한다.
즉, select문은 여러 개의 case문에서 각각 다른 채널을 기다리다가 준비가 된 채널 case를 실행하는 것이다.

select문은 case 채널들이 준비되지 않으면 계속 대기하게 되고, 가장 먼저 도착한 채널의 case를 실행한다.
만약 복수 채널에 신호가 오면, Go 런타임이 랜덤하게 그 중 한 개를 선택한다.

하지만, select문에 default 문이 있으면, case문 채널이 준비되지 않더라도 계속 대기하지 않고 바로 default문을 실행한다.

Go 언어의 select 문은 여러 채널에서 송수신 작업을 동시에 기다리면서 준비된 채널에 대해 작업을 수행할 수 있는 구조
- 마치 switch 문처럼 동작하지만, select 문은 채널 작업에 특화되어 있다.

1) 동시성: select 문은 여러 채널에서 데이터를 동시에 기다리면서 가장 먼저 준비된 채널의 작업을 처리
2) 비동기 처리: 고루틴과 함께 사용하면 비동기적으로 여러 작업을 동시에 수행 가능
3) 우선순위: 여러 채널이 동시에 준비되면, Go는 랜덤하게 하나를 선택하여 실행

select문은 여러 채널을 동시에 기다릴 수 있다
만약 어떤 채널이라도 하나의 채널에서 데이터를 읽어오면 해당 구문을 실행하고 select문이 종료된다
하나의 case만 처리되면 종료되기 때문에 -> 반복해서 데이터를 처리하고 싶다면 for문과 함께 사용한다
*/

package main

import (
	"fmt"
	"time"
)

func main() {

	fmt.Println("Channel과 select에 대해 알아보자\n")

	// 1. 채널 생성: ch1과 ch2
	// 두 채널 모두 버퍼 크기가 0인 unbuffered 채널
	// 즉, 송신자와 수신자가 동시에 준비되어야만 데이터를 주고받을 수 있다.
	// ->> unbuffered 채널이기 때문에 송신자는 수신자가 데이터를 받을 준비가 될 때까지 블록
	ch1 := make(chan string) // 버퍼 크기가 0인 채널
	ch2 := make(chan string) // 버퍼 크기가 0인 채널

	// 2. 첫 번째 고루틴: ch1에 데이터를 전송하는 송신자
	// 송신자는 데이터를 채널에 보내는 고루틴
	go func() {
		time.Sleep(1 * time.Second) // 1초 대기 (즉시 전송하지 않고 1초 후에 전송)
		ch1 <- "ch1에서 수신된 메시지"      // ch1에 문자열 데이터를 전송
	}()

	// 3. 두 번째 고루틴: ch2에 데이터를 전송하는 송신자
	go func() {
		time.Sleep(2 * time.Second) // 2초 대기 (2초 후에 전송)
		ch2 <- "ch2에서 수신된 메시지"      // ch2에 문자열 데이터를 전송
		// -> 이때 메인 고루틴이 수신자로서 준비되지 않았기 때문에, ch1과 ch2에 데이터를 보내려는 고루틴들은 데이터를 전송하려다가 수신자가 나타날 때까지 블록된다
	}()

	// 3-1. 메인 고루틴의 대기
	time.Sleep(5 * time.Second)

	// 4. 메인 고루틴이 5초 후 꺠어나 select 문을 사용하여 채널 데이터를 수신
	// 메인 고루틴: 수신자
	// - select 문을 사용하여 ch1과 ch2에서 데이터를 수신하려고 시도
	// - select 문이 실행되면 ch1과 ch2 중에서 데이터를 수신할 수 있는 채널을 확인
	select { // 어떤 게 먼저 실행될 지 장담 불가능 (고루틴 순서도 마찬가지)
	case msg2 := <-ch2:
		fmt.Println("수신된 데이터:", msg2)
	case msg1 := <-ch1:
		fmt.Println("수신된 데이터:", msg1)
	default:
		fmt.Println("어느 채널에서도 데이터가 도착하지 않았습니다.")
	}
	// -> 메인 고루틴이 5초 대기하는 동안에 두 고루틴은 송신하려고 대기하고 있다가, 메인 고루틴이 select 문을 실행함으로써 데이터를 송신

	// 프로그램 종료 전 대기: 고루틴이 종료될 수 있는 시간을 확보
	time.Sleep(3 * time.Second)
}

/*
select 문 작동 방식
1. 채널 준비 상태 확인
: select 문이 실행되면, 각 case에서 수신하려는 채널을 확인
- 만약 하나 이상의 채널에서 데이터를 수신할 준비가 되어 있다면, 그 중 하나를 임의로 선택하여 해당 case 블록을 실행

2. 여러 채널이 준비된 경우
: 만약 여러 채널에서 데이터를 수신할 수 있는 상태라면, Go 런타임은 그 중 하나를 랜덤하게 선택하여 실행

3. 채널이 준비되지 않은 경우
: 만약 어떤 채널에서도 데이터를 받을 준비가 되어 있지 않다면, default 블록이 실행
- default 블록이 없으면 select 문은 블록 상태로 대기하게 되며, 나중에 채널이 준비되면 그때 case가 실행

4. 하나의 case만 실행
: select 문은 한 번에 오직 하나의 case 또는 default 블록만 실행

//

+ 수신자?
- 수신자는 select 문을 통해 ch1 또는 ch2에서 데이터를 읽어들이는 메인 고루틴
- 다시 말해, 메인 고루틴이 select 문을 실행할 때, 그때 ch1 또는 ch2에서 데이터를 수신할 준비가 되어있다면! 고루틴은 대기 상태에서 풀려서 데이터를 송신할 수 있다.

++
1. 메인 고루틴이 시작될 때: main 함수가 실행되면서 메인 고루틴이 시작

2. 채널과 고루틴 생성: 메인 고루틴이 ch1과 ch2라는 두 개의 채널을 생성
- 다음으로 두 개의 고루틴을 생성하여 각각 ch1과 ch2로 데이터를 송신하도록 한다
-- 고루틴은 비동기적으로 실행되기 때문에, 메인 고루틴과 동시에 실행

3. 고루틴의 데이터 송신 시도: 각각의 고루틴은 데이터 송신을 시도
- 그러나 이 경우 채널이 unbuffered이기 때문에, 데이터를 송신하려면 수신자가 필요
- 고루틴이 데이터를 송신하려고 할 때, 메인 고루틴이 수신할 준비가 되어 있어야 송신이 완료, 그렇지 않으면 고루틴은 블록

4. 메인 고루틴의 대기: 메인 고루틴은 time.Sleep(3 * time.Second)로 3초 동안 대기
- 이 시점에서 고루틴들은 데이터를 송신하려고 대기하고 있다.

5. 메인 고루틴이 select 문을 실행: 3초 후, 메인 고루틴이 다시 실행되고 select 문을 실행
- 이 시점에서 메인 고루틴은 채널 ch1과 ch2에서 수신할 준비가 되어 있으며, 고루틴들이 데이터를 송신할 수 있는 상태

6. 데이터 송신 및 수신: 메인 고루틴이 select 문을 실행함으로써, 고루틴들이 데이터 송신을 완료할 수 있는 상태
- 이때 select 문에서 준비된 채널에서 데이터를 수신하고 처리
*/
