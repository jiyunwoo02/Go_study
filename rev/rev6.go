/*
* 6. 데드락 의미
- go 프로그램에서 deadlock detect case)

=> Go 언어는 기본적으로 데드락을 자동으로 감지하거나 해결하는 기능을 제공하지 않는다.
그러나 개발자가 데드락 상황을 감지하고 처리할 수 있는 방법을 구현할 수는 있다.

데드락 (DeadLock) : 프로그램 내의 프로세스들이 타 프로세스의 자원을 필요로 해서
-> 이를 얻기 위해 타 프로세스가 종료되기를 무한정 기다리는 상태를 같이 가질 때 생기는 문제
=> 즉 외부 개입 없이는 프로그램이 정상적으로 진행할 수 없음

Go 언어에서 데드락은 두 개 이상의 고루틴이 서로 상대방의 작업이 끝나기를 기다리며 무한 대기상태에 빠지는 상황을 말한다
- 이는 프로그램이 더 이상 진행되지 않게 되어, 결국 멈춰버리는 문제를 일으킨다.

데드락 발생 주요 원인
1) 채널 사용
: 버퍼링되지 않은 채널에서 고루틴이 데이터를 전송하려 하지만, 수신자가 없어 송신자가 영원히 대기하는 경우
: 서로 다른 두 고루틴이 서로의 채널로 데이터를 전송하려 하면서, 동시에 수신자가 없어 대기하는 경우

2) 뮤텍스 사용
: 두 개의 고루틴이 서로가 소유하고 있는 자원을 필요로 하면서, 서로를 기다리는 경우

데드락 방지 방법
1) 채널 설계
: 버퍼링되지 않은 채널 사용 시 -> 송신자와 수신자가 동시에 존재하는지 확인
- 버퍼링된 채널을 사용하여 송신자가 수신자가 준비되기 전에 데이터를 보낼 수 있도록 함

2) 뮤텍스 관리
: 고루틴 간 자원을 공유할 때, 뮤텍스를 적절히 사용하여 서로의 자원을 기다리며 무한 대기하지 않도록 설계s

3) 타임아웃 설정
: select문에서 default 케이스를 사용하거나 타임아웃을 설정하여 -> 특정 작업이 완료되지 않을 경우, 대기를 중단하고 다른 작업을 수행할 수 있도록 함
*/

package main

import (
	"fmt"
	"sync"
	"time"
)

// 두 개의 뮤텍스 선언
var mutex1 sync.Mutex
var mutex2 sync.Mutex

func main() {

	fmt.Println("Deadlock에 대해 알아보자")

	// 데드락 감지용 타임아웃 채널 생성
	timeout := 10 * time.Second        // 10초 후에 타임아웃 발생시키는 채널 생성
	timeoutChan := time.After(timeout) // 타임아웃이 발생할 채널

	// Go에서 고루틴은 병렬로 실행된다!
	// 두 개의 고루틴을 생성하여 각각의 뮤텍스를 다루게 한다
	go func() {
		// 첫 번째 고루틴: mutex1을 먼저 잠그고, mutex2를 잠그려 시도
		fmt.Println("Goroutine 1: trying to lock mutex1")
		mutex1.Lock() // mutex1 잠금 -> 획득
		fmt.Println("Goroutine 1: locked mutex1")

		time.Sleep(1 * time.Second) // 1초 대기

		fmt.Println("Goroutine 1: trying to lock mutex2")
		mutex2.Lock() // mutex2 잠금 시도
		fmt.Println("Goroutine 1: locked mutex2")

		// 잠금을 해제
		mutex2.Unlock() // mutex2 잠금 해제 -> 반납
		mutex1.Unlock() // mutex1 잠금 해제
	}()

	go func() {
		// 두 번째 고루틴: mutex2를 먼저 잠그고, mutex1을 잠그려 시도
		// - 첫 번째 고루틴과 반대 순서로 잠금을 시도 -> 이로 인해 데드락 발생 가능성 있음
		fmt.Println("Goroutine 2: trying to lock mutex2")
		mutex2.Lock() // mutex2 잠금
		fmt.Println("Goroutine 2: locked mutex2")

		time.Sleep(1 * time.Second) // 1초 대기

		fmt.Println("Goroutine 2: trying to lock mutex1")
		mutex1.Lock() // mutex1 잠금 시도
		fmt.Println("Goroutine 2: lock mutex1")

		// 잠금을 해제
		mutex1.Unlock() // mutex1 잠금 해제
		mutex2.Unlock() // mutex2 잠금 해제
	}()

	// 메인 고루틴에서 타임아웃을 감지
	for {
		select {
		case <-timeoutChan:
			// 타임아웃이 발생하면, 데드락을 감지하고 프로그램을 종료
			fmt.Println("타임아웃 발생: 데드락이 발생했습니다.")
			return // 프로그램 종료
		default:
			// 타임아웃이 발생하지 않은 경우, 계속해서 대기
			time.Sleep(100 * time.Millisecond) // CPU 과다 사용을 방지하기 위해 짧은 시간 대기
		}
	}
}

/*
첫 번째 고루틴은 mutex1을 잠근 후 mutex2를 잠그려 시도
두 번째 고루틴은 mutex2를 잠근 후 mutex1을 잠그려 시도

-> 두 고루틴이 서로가 잠그고 있는 뮤텍스를 기다리면서 데드락 상태가 발생
=> 이로 인해 프로그램은 무한히 대기

-> 데드락을 방지하려면 뮤텍스를 잠그는 순서를 일관되게 유지하거나, 타임아웃을 사용하는 등의 방법이 필요

[자세히 들여다보자]
고루틴 1이 mutex1을 먼저 잠그고, mutex2를 잠그려고 시도
- mutex1은 현재 고루틴 1이 보유하고 있다.
- mutex2는 아직 잠금되지 않았다.

고루틴 2가 mutex2를 먼저 잠그고, mutex1을 잠그려고 시도
- mutex2는 현재 고루틴 2가 보유하고 있다.
- mutex1은 아직 잠금되지 않았습니다.

고루틴 1은 mutex2를 잠그기 위해 대기
- 하지만, mutex2는 현재 고루틴 2가 보유하고 있으며, 고루틴 2는 mutex1을 잠그기 위해 대기하고 있다.

고루틴 2는 mutex1을 잠그기 위해 대기
- 하지만, mutex1은 현재 고루틴 1이 보유하고 있으며, 고루틴 1은 mutex2를 잠그기 위해 대기하고 있다.

[데드락 상황 요약]
고루틴 1이 mutex1을 잠그고, mutex2를 잠그려고 대기
고루틴 2가 mutex2를 잠그고, mutex1을 잠그려고 대기

결과적으로:
고루틴 1은 mutex2를 잠그려 하고 있지만, mutex2를 보유하고 있는 고루틴 2가 mutex1을 잠그려 하고 있다.
고루틴 2는 mutex1을 잠그려 하고 있지만, mutex1을 보유하고 있는 고루틴 1이 mutex2를 잠그려 하고 있다.

이로 인해 서로가 서로의 자원을 기다리며, 두 고루틴 모두 진행되지 못하고 무한히 대기하는 상황이 발생하는데 이 상태가 데드락

=> 두 고루틴이 서로 동일한 순서로 자원을 잠글 때 데드락 방지 가능! (모든 고루틴이 자원을 잠글 때 동일한 순서로 자원 요청)
*/

/*
<추가 의문> 동일한 순서로 뮤텍스 획득하면 왜 데드락 발생 안 하나?

데드락은 순환 대기(circular wait)로 인해 발생
- 두 개 이상의 고루틴이 서로가 보유한 자원을 기다리면서 교착 상태가 되는 것

데드락이 발생하기 위해서는 다음 네 가지 조건이 모두 충족되어야 한다:
1. 상호 배제(Mutual Exclusion): 자원은 한 번에 하나의 고루틴만 사용할 수 있어야 한다.
2. 점유와 대기(Hold and Wait): 자원이 점유된 상태에서 다른 자원을 요청해야 한다.
3. 비선점(No Preemption): 자원을 보유한 고루틴이 자원을 강제로 반환할 수 없다.
4. 순환 대기(Circular Wait): 자원을 대기하는 고루틴들이 순환적으로 자원을 요청하고 있어야 한다.

=>  같은 순서로 뮤텍스를 잠그면?
- 순서 일관성: 두 고루틴이 모두 동일한 순서로 뮤텍스를 잠그고 있다.
	즉, mutex1을 먼저 잠그고, mutex2를 잠근다.
	순서가 일관되면, 한 고루틴이 자원을 점유하고 있을 때 다른 고루틴이 동일한 순서로 자원을 잠그려고 할 것이므로 순환 대기가 발생하지 않는다.

- 데드락 방지: 순서가 일관되면 고루틴들이 자원을 요청할 때 항상 동일한 순서를 따르기 때문에, 서로가 보유한 자원을 기다리는 상황이 발생하지 않는다.
	두 고루틴 모두 mutex1과 mutex2를 잠그는 동일한 순서를 따르므로, 데드락이 발생하지 않는다.

그러나, 데드락 발생 조건 4가지를 모두 해결하는 건 아니다!
=> 동일한 순서로 자원을 잠그는 것은 데드락을 방지하는 효과적인 방법이지만,
이것이 모든 데드락 조건을 직접적으로 해결하는 것은 아니다.
자원 잠금 순서에 따라 순환 대기를 방지할 수 있지만, 상호 배제, 점유와 대기, 비선점 등의 조건은 여전히 존재하며, 이러한 조건들은 프로그램 설계 시 고려되어야 한ㄴ다.

1. 상호 배제 (Mutual Exclusion)
설명: 자원은 한 번에 하나의 고루틴만 사용할 수 있다.
해결 여부: 자원 잠금 순서와 관계없이 상호 배제는 여전히 유지된다.
- 즉, 뮤텍스는 한 번에 하나의 고루틴만 잠글 수 있다.
- 자원을 같은 순서로 잠그더라도, 한 고루틴이 자원을 점유하고 있으면 다른 고루틴은 점유된 자원을 사용할 수 없다.

2. 점유와 대기 (Hold and Wait)
설명: 자원을 점유한 고루틴이 다른 자원을 기다리는 경우.
해결 여부: 자원 잠금 순서가 동일하다고 해서 점유와 대기 조건이 해결되는 것은 아니다.
- 고루틴이 이미 점유한 자원을 가지고 다른 자원을 기다릴 수 있다.
- 다만, 동일한 순서로 자원을 잠그면 서로 교착 상태에 빠질 가능성이 줄어듭니다.

2. 점유와 대기 (Hold and Wait)
설명: 자원을 점유한 고루틴이 다른 자원을 기다리는 경우.
해결 여부: 자원 잠금 순서가 동일하다고 해서 점유와 대기 조건이 해결되는 것은 아니다.
- 고루틴이 이미 점유한 자원을 가지고 다른 자원을 기다릴 수 있다.
- 다만, 동일한 순서로 자원을 잠그면 서로 교착 상태에 빠질 가능성이 줄어든다.

4. 순환 대기 (Circular Wait)
설명: 자원을 기다리는 고루틴들이 순환하는 형태로 대기 상태에 있다.
해결 여부: 동일한 순서로 자원을 잠그면 순환 대기 조건이 제거된다.
- 고루틴이 자원을 요청할 때, 항상 일정한 순서로 자원을 요청하므로, 교착 상태가 발생하지 않게 된다.
- 예를 들어, 모든 고루틴이 항상 mutex1을 먼저 잠그고 mutex2를 잠그려 하면, 순환 대기가 발생하지 않는다.
*/
