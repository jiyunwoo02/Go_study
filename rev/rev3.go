/* 3. Range 사용 대상에 따른 동작 확인
- 채널, 슬라이스(배열), 맵
- 열린 채널, 닫힌 채널

Go에서 range 키워드는 반복문에서 다양한 자료구조를 순회(iterate)하는 데 사용된다

1) 채널 (Channel):
range를 사용하여 채널에서 값을 반복해서 읽을 수 있다.
- 채널이 닫힐 때까지 반복이 지속된다!
- 채널은 make를 통해 생성되며, 생성 시점에서 열린 상태!

채널에서 송신자가 송신을 한 후, 채널을 닫을 수 있다.
그리고 수신자는 임의의 갯수의 데이타를 채널이 닫힐 때까지 계속 수신할 수 있다.
채널 range문은 range 키워드 다음의 채널로부터 계속 수신하다가 채널이 닫힌 것을 감지하면 for 루프를 종료한다.

채널을 오픈한 후 데이타를 송신한 후, close()함수를 사용하여 채널을 닫을 수 있다.
채널을 닫게 되면, 해당 채널로는 더이상 송신을 할 수 없지만, 채널이 닫힌 이후에도 계속 수신은 가능하다.

버퍼가 있는 채널은
- 데이터를 비동기적으로 송신할 수 있게 해주며,
- 송신자는 수신자가 데이터를 수신하기 전까지 대기하지 않고 계속해서 데이터를 전송할 수 있다.

[채널의 사용 시점]
[1] 채널 열림: 데이터 전송이 필요할 때 채널이 열려 있어야 한다! 데이터 전송을 완료한 후에는 채널을 닫을 수 있다.
[2] 채널 닫힘: 데이터 전송이 모두 완료된 후 채널을 닫아야 한다! 채널을 닫지 않으면, 수신자는 채널이 아직 열려 있다고 가정하고 계속해서 데이터를 수신하려고 할 수 있다.

2) 슬라이스 (Slice):
슬라이스의 모든 요소를 순회할 때 사용된다 (배열도 마찬가지!)

3) 맵 (Map):
range를 사용하여 맵의 키-값 쌍을 순회할 수 있다

*/

package main

import "fmt"

func main() {
	fmt.Println("Range와 Channel에 대해 알아보자")

	// 1. 채널과 Range
	fmt.Println("\n1. 채널 예제")

	ch := make(chan int, 3) // int 타입의 버퍼가 3인 채널을 생성 -> 최대 3개의 int 값을 저장할 수 있는 버퍼

	// 메인 고루틴은 for 루프를 통해 채널에서 데이터를 수신하려고 기다리며, 고루틴은 채널에 데이터를 전송하고 채널을 닫는다

	go func() { // 고루틴을 사용하여 채널에 데이터를 전송
		for i := 0; i < 3; i++ { // 고루틴 내부에서 for 루프 사용해 ~
			ch <- i // 채널에 0부터 2까지의 데이터를 전송 (채널이 가득 차기 전에 계속해서 데이터 전송 가능)
		}
		close(ch) // 데이터 전송이 완료되면(데이터를 송신한 후) 채널을 닫는다.
		// -> 채널을 닫으면, 더 이상 데이터를 송신할 수 없지만, 이미 송신된 데이터는 계속 수신할 수 있다.
	}()

	// 메인 고루틴에서 `range`를 사용하여 채널에서 데이터를 수신
	// 메인 고루틴이 for 루프를 시작하고, 동시에 고루틴이 채널에 데이터를 전송

	for val := range ch { // range 문은 채널이 닫힐 때까지 반복하여 채널에서 데이터를 읽는다
		// => 채널이 닫힌 상태에서 채널의 버퍼에 데이터가 모두 소모되면, range 문은 더 이상 데이터가 없기 때문에 종료
		fmt.Println("채널로부터 수신한 값 : ", val)
	}
	// 메인 고루틴의 for 루프는 채널에 데이터가 들어오면 데이터를 수신하여 출력하며, 고루틴은 채널에 데이터를 보내고 채널을 닫는 작업을 진행

	// 2. 슬라이스와 Range
	// : 슬라이스의 첫 번째 요소부터 마지막 요소까지 순차적으로 접근
	fmt.Println("\n2. 슬라이스 예제")

	slice := []int{10, 20, 30, 40} // 정수형 슬라이스를 생성

	// `range`를 사용하여 슬라이스를 반복
	// 각 요소의 인덱스와 값을 출력
	for idx, val := range slice {
		fmt.Printf("인덱스: %d, 값: %d\n", idx, val) // Printf를 사용하여 출력 형식을 세밀하게 조정
	}

	// 3. 맵과 Range
	// : 맵의 모든 키-값 쌍을 확인할 때까지 순회
	fmt.Println("\n3. 맵 예제")

	m := map[string]int{"a": 100, "b": 200, "c": 300} // 문자열 키와 정수 값을 가지는 맵을 생성

	// `range`를 사용하여 맵을 반복
	// 각 키와 값을 출력
	// : 다만, 슬라이스와는 달리, 맵은 순회할 때 요소가 무작위 순서로 반환될 수 있다.
	for key, value := range m {
		fmt.Printf("키 : %s, 값: %d\n", key, value)
	}
}

/*
1. 채널에 데이터를 3번 넣는다

2. for range 구문을 사용하면 채널에서 데이터를 계속 기다릴 수 있다
- ch 채널 인스턴스로부터 데이터가 들어오기를 기다렸다가,
- 데이터가 들어오면 데이터를 빼내서 val 변수에 값 복사하고,
- for 본문 실행

3. for range 구문은 채널에 데이터가 들어오기를 계속 기다린다
- 채널을 다 사용하면 채널을 닫고 알려준다
- 채널에서 데이터를 모두 빼낸 상태이고 채널이 닫혔으면 for range문 빠져나간다

-> 데이터를 모두 넣고 채널이 더는 필요없어지면 채널을 닫는다
-> for range에서 데이터를 모두 처리하고 난 다음에 채널이 닫힌 상태이면 for문 종료해서 프로그램 정상 종료된다

*/
/*
모든 데이터를 전송한 후 close(ch)를 호출하여 채널을 닫는다
- 채널을 닫으면, 더 이상 데이터를 전송할 수 없으며, 채널의 수신자는 채널이 닫힌 것을 감지

range 문을 사용하여 채널에서 데이터를 수신
- range 문은 채널이 닫힐 때까지 반복
- 채널이 닫힐 때까지 range 문은 계속 실행되며, 채널이 닫히면 range 문이 자동으로 종료

고루틴을 사용하여 데이터를 채널에 전송하는 과정과, FOR 루프를 사용하여 채널에서 데이터를 쉰하는 과정은 서로 독립적으로 병행되어 실행된다
고루틴과 메인 루틴은 동시에 실행되며, 서로 독립적으로 다른 작업 수행
- 고루틴: 데이터를 채널에 전송
- 메인 루틴: RANGE문을 사용하여 채널에서 데이터를 수신

[1] 채널이 열려 있을 때: 데이터 전송이 계속되고, 메인 고루틴은 range 문을 통해 데이터를 수신
[2] 채널이 닫힐 때: 채널이 닫히면, range 문은 더 이상 데이터를 수신하지 않고 루프를 종료, 채널이 닫히면 수신 루프는 종료

# 메인 고루틴에서 for 루프를 실행하기 전에 이미 채널이 닫혀 있어도,
for 루프는 채널이 닫히기 전까지 수신된 데이터를 모두 처리하고 루프를 종료
-> 채널에 남아있는 모든 데이터가 수신된 이후에 RANGE문 종료된다

# 고루틴이 채널을 닫은 후에도,
for 루프는 정상적으로 작동하며 채널이 닫힐 때까지 데이터를 수신합니다.
*/

/* 추가 의문
1. 채널에 있는 데이터를 두 고루틴이 동시에 접근하는 데 뮤텍스 사용 안해도 되나?

채널은 기본적으로 동기화 메커니즘을 내장하고 있다.
- 이는 데이터 전송과 수신이 안전하게 이루어지도록 보장한다.
- 채널이 비어 있거나 가득 차지 않은 경우 자동으로 동기화

Unbuffered 채널: 송신자가 데이터 전송을 시도할 때 수신자가 수신할 준비가 되어 있어야 한다
- 이 경우 채널의 동기화가 자연스럽게 이루어진다

Buffered 채널: 송신자는 채널의 버퍼가 가득 차기 전까지 데이터를 전송할 수 있다.
- 수신자는 버퍼에 데이터가 있는 경우 이를 수신
- 채널이 가득 찼을 때는 송신자가 블록되고, 버퍼가 비어 있을 때는 수신자가 블록

+ 뮤텍스와 채널의 차이
1) 뮤텍스(Mutex): 주로 공유 자원에 대한 접근을 제어하여 동시에 여러 고루틴이 동일 자원에 접근하지 못하게 한다
- 이는 동기화의 기본적인 방법 중 하나로, 데이터의 일관성을 보장

2) 채널(Channel): 고루틴 간의 통신을 위한 구조로, 데이터를 안전하게 전송하고 수신할 수 있게 한다.
- 채널 자체가 동기화의 역할을 하므로, 채널을 사용할 때는 뮤텍스가 필요하지 않다.
*/
